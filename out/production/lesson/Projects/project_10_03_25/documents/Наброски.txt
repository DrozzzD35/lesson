Трекер задач
В итоге должна получиться программа, отвечающая за формирование модели данных 

* class Task
Поля: 
Название. name
Описание. description
Уникальный идентификационный номер задачи. Например можно использовать UUID (String uniqueID = UUID.randomUUID().toString())
Enum Статус:	a. NEW — задача только создана, но к её выполнению ещё не приступили.
		b. IN_PROGRESS — над задачей ведётся работа.
		c. DONE — задача выполнена.



В системе существует 3 типа задач: обычные задачи, эпики и подзадачи. 
Задачи, эпик и подзадачи - HashMap<Идентификатор, задача>
Создать публичный не абстрактный класс Task. 
Далее от него создать два подкласса: Subtask и Epic. 



* class Manager
Генерируем идентификатор, увеличивая на 1 каждый раз при использовании.
Хранит задачи всех типов (обычные, эпики и подзадачи)
Методы задач:	a. getAllTask Получение списка всех задач.
		b. removeAllTask Удаление всех задач.
		c. getById Получение по идентификатору.
		d. addTask Создание. Сам объект должен передаваться в качестве параметра.
		e. updateTask Обновление. Новая версия объекта с верным идентификатором передаётся в виде параметра.
		f. removeById Удаление по идентификатору.

Дополнительные методы:	
a. getSubtaskByEpic Получение списка всех подзадач определённого эпика.

Управление статусами:
a. Информация о статусе приходит с информацией о задаче. По этим данным в одних случаях он будет сохранять статус, в других будет рассчитывать. (что значит рассчитывать? Обновлять и менять? Прим. NEW > IN_PROGRESS ?)

Эпик:
Эпик имеет статус NEW, все подзадачи имеют статус  NEW.
Эпик имеет статус DONE, все подзадачи имеют статус  DONE.
В остальных случаях IN_PROGRESS.
При обновлении создаётся новая задача и полностью заменяет старую. Обновление — это запись нового эпика tasks.put(task.getId(), task)).
Обновляется задача - обновляется статус. Без отдельных методов.
Статус Эпика меняется автоматически, изменение статуса пользователем для эпика заблокировано


По итогу выполнить:
Проверка кода называется тестированием. Мы будем подробно рассказывать об этом дальше в курсе. Тем не менее, сам процесс тестирования можно начать уже сейчас. Создайте в классе Main методstatic void main(String[] args) и внутри него:
Создайте 2 задачи, один эпик с 2 подзадачами, а другой эпик с 1 подзадачей.
Распечатайте списки эпиков, задач и подзадач, через System.out.println(..)
Измените статусы созданных объектов, распечатайте. Проверьте, что статус задачи и подзадачи сохранился, а статус эпика рассчитался по статусам подзадач.
И, наконец, попробуйте удалить одну из задач и один из эпиков.

Воспользуйтесь дебаггером, поставляемым вместе со средой разработки, что бы понять логику работы программы и отладить.
Не оставляйте в коде мусор — превращённые в комментарии или ненужные куски кода. Это сквозной проект, на его основе вы будете делать несколько следующих домашних заданий.
Давайте коммитам осмысленные комментарии: порядок в репозитории и коде — ключ к успеху написания хороших программ.


Перед тем как приступить к задаче ответьте себе на вопросы:
1) Как распределяется функциональность приложения между классами?
2) Как классы должны взаимодействовать друг с другом ?
3) Как применить принципы ООП и построить систему наследования?
4) Какой способ выбрать для хранения задач?
5) Должен ли быть у приложения интерфейс?

Ответы:
1, 2) Main - точка входа в программу
 Manager - основная логика приложения. Manager обращается к классу Task для создания задач и добавляет в HashMap. Выполняет основные манипуляции с задачами
 enum Status - создаём статусы и обновляем их
4) Задачи хранятся в HashMap
5) В интерфейсе ведётся взаимодействие с пользователем. Пользователь сможет создавать конкретный тип задач. Выводить информацию о задачах и их статусе

