## 1. Расширенная система заказов в ресторане с «жизненным циклом» блюд

1. Создайте абстрактный класс `MenuItem` (блюдо/напиток) с полями:
- `name` (наименование),

- `price` (стоимость),

- `status` (например, “Заказано”, “Готовится”, “Подано”).

- Абстрактные методы: `prepare()`, `serve()`.

2. Классы `Dish` и `Drink` расширяют `MenuItem`, но у них могут быть разные статусы или разные способы подготовки (например, `Dish` готовится на кухне, а `Drink` может быть налит или смешан из ингредиентов).

3. Создайте класс `Order`, содержащий **список**  `List<MenuItem>`:
- Методы `addItem(MenuItem item)`, `removeItem(MenuItem item)`.

- Метод `advanceAllStatuses()`, который последовательно обновляет `status` каждого блюда (например, «Заказано» -> «Готовится» -> «Подано») и вызывает соответствующие методы `prepare()` или `serve()`.

- Метод `getTotalPrice()`.

4. Создайте класс `Kitchen`, который работает **совместно**  с `Order`:
- При поступлении заказа на блюдо (`Dish`) выводит, что оно готовится (или передаёт сообщение в `Dish`, что оно может перейти в статус «Готовится»).

- Для напитков может быть отдельный класс `Bar`, который аналогично взаимодействует со `Drink`.

5. В `main`:
- Создайте несколько заказов с разным набором блюд и напитков.

- Смоделируйте процесс: «Гость заказал -> Кухня приняла заказ -> Напитки смешиваются на баре -> Всё подаётся гостю».

- Проверьте, что статусы блюд корректно сменяются, а итоги заказов (стоимость, список) корректно выводятся.
  **Дополнительные взаимодействия** :
- Используйте **инкапсуляцию**  полей (чтобы статус нельзя было установить напрямую «вдруг»).

- При изменении статуса блюда в `Order` может автоматически вызываться метод в `Kitchen` (или `Bar`), эмулируя «событийную» модель взаимодействия.






## 2. Автопарк с автоматической диспетчерской системой

1. Создайте абстрактный класс `Vehicle`:
- Поля: `brand`, `speed`, `status` (например, «На стоянке», «В пути», «В ремонте»).

- Абстрактный метод `moveTo(String destination)`.

2. Классы `Car`, `Bus`, `Truck` наследуют `Vehicle` и по-своему реализуют логику перемещения:
- У `Car` — ограничение по числу пассажиров.

- У `Bus` — система «остановок».

- У `Truck` — учёт груза и максимальной грузоподъёмности.

3. Создайте класс `FleetManager`:
- **Список**  (`List<Vehicle>`) или **массив**  `Vehicle[]`, если хотите задать ограничение.

- Методы `addVehicle()`, `removeVehicle()`, `dispatchAll(String destination)` – отправляет все доступные ТС в заданное место, меняя им статус и вызывая `moveTo()`.

4. Создайте класс `MaintenanceService`, который «реагирует» на события ремонта:
- При попытке `dispatchAll` проверяет, какие ТС имеют флаг «Требует ремонта» (можно смоделировать через дополнительное поле или метод в `Vehicle`).

- Отправляет их в ремонт (меняет статус).

5. В `main`:
- Добавьте в автопарк разные машины, автобусы, грузовики.

- Попробуйте отправить их на разные задания, учитывая, что какие-то из них могут «сломаться» и уйти в ремонт.
  **Дополнительные взаимодействия** :
- Продемонстрируйте **двустороннюю**  связь: `MaintenanceService` может уведомлять `FleetManager` о том, что машина готова, и тот снова переводит её в «На стоянке».

- Инкапсуляция статуса и проверка логики (например, нельзя ехать, если «Требует ремонта»).



































